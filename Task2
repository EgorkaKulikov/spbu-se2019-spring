1) Программа №220 представляет собой не что иное как интерпретатор и компилятор для
языков BrainFuck и Petooh
   1. класс Commands представляет собой набор элементарных команд:
      - SHIFT = сдвиг указателя на ячейку памяти вправо
      - ADD = прибавление еденицы к ячейке памяти, на которую указывает указатель
      - ZERO = обнуление ячейки памяти, на которую указывает указатель
      - OUT = вывод символа, соответствующего коду текущей ячейки, на экран
      - IN = ввод одного символа и запись его кода в текущую ячейку памяти
      - WHILE = начало цикла, который выполняется пока текущая ячейка памяти ненулевая
      - END = конец цикла (эквивалент закрывающейся скобке)
   2. класс Operations - это класс операций. Операция - это грубо говоря пара вида
      (type: Commands, amount: Int), где type - это собственно говоря команда, которую
      необходимо сделать, а amount - сколько раз её нужно сделать (amount может быть
      отрицательным)
   3. абстрактный класс Code представляет из себя массив операций Operations - это,
      собственно, код, написанный на нашем внутреннем языке программирования. Разберём
      2 основные функции этого класса:
      - fun optimize (oldArr : ArrayList<Operations>) : ArrayList<Operations>
          оптимизирует принимаемый код, а именно если есть несколько идущих подряд
          операций с одинаковой командой (и эта команда не WHILE и не END), то эти
          операции заменяются новой операцией с той же командой, как и у старых
          операций, и количеством повторений = сумме количеств повторений у старых
          операций (если команда равна, ZERO, то вместо суммы ставится 1)
      - fun isCorrect() : Boolean
          проверяет код на правильность скобочной последовательности, где открывающая
          скобка - WHILE, а закрывающая - END
   4. класс FileL позволяет считывать текст из файла, имя которого передаётся в
      конструктор класса, вызывая метод readFile()
   5. класс BrainFuckCode является наследником класса Code и представляет собой
      программу на BrainFuck. Разберём 2 конструктора и функцию этого класса:
      - constructor (str : String) и constructor (file : FileL)
          конструктор принимает либо программу на BrainFuck, написанную в строке, либо
          файл с кодом программы, преобразует в набор наших внутренних операций и
          оптимизирует их
      - fun tokenize () : ArrayList<Operations>
          эта функция, собственно, посимвольно преобразует код на BrainFuck в
          последовательность наших операций, дополнительно оптимизируя (вместо кода
          "[+]" и "[-]" генерирует операцию (ZERO, 1))
   6. класс PetoohCode также является наследником класса Code и представляет собой
      прогрмму на диалекте BrainFuck Petooh. Все функции (кроме isSubstring
      (index : Int, prototype : String) : Boolean, которая проверяет совпадение
      подстроки кода с индекса index и строки prototype) аналогичны функциям класса
      BrainFuck
   7. класс Interpreter является интерпретатором и принимает код Code на выполнение.
      Рассмотрим 2 функции этого класса:
      - fun interpret ()
          последовательно выполняет код, сопостовляя каждой операции типа Operations
          команды на языке Kotlin
      - fun findEndBracket(comandInd : Int) : Int
          ищет коменду END, соответствующую команде WHILE, которая стоит на месте
          comandInd - 1
   8. класс Compiler является компилятором в байт-код java и принимает код Code на
      компиляцию. Рассмотрим 3 публичные функции этого класса:
      - fun generateClassByteArray(): ByteArray
          генерирует байт-код программы
      - fun saveToDisk(classByteArray: ByteArray)
          сохраняет байт-код в файл с расширением .class
      - fun loadClassAndRun(classByteArray: ByteArray): Any?
          загружает байт-код-программу, ищет функцию main() и если находит, то
          возвращает результат её работы
   9. класс GeneralTests представляет собой, собственно, тесты преобразования кода с
      Brainfuck или Petooh в наши внутренние команды и тесты работы интерпретатора и
      компилятора
   В целом программа работает так: пусть нам ввели программу (или имя файла с
   программой) на языке Brainfuck или Petooh (но мы знаем, какой язык использовался).
   Теперь мы можем либо интерпретировать её, либо скомпилировать, сохранить и
   запускать её необходимое количество раз
2) К программе №220 почти нет комментариев, да и половина из тех, что были, уже
   исправлены, но лично я не понял проблему, описанную в коментарии "не везде
   соблюдается единый стиль в for", так как по-моему строчка с for корректная и
   подобные ей также встречаются в коде программы. С замечанием " "+[+]." заканчивает
   работу, ничего не выводя (должен зациклиться же?)" был согласен до прочтения ответа
   автора кода, но допускаю, что можно было вместо "безошибочного переполнения" (не
   цитата) либо предупреждать о переполнении во время исполненияб либо выбрасывать
   исключение. Также можно было добавить защиту от зацикливания (например, во время
   выполнения программы в хеш-таблице хранить состояние всех ячеек + значение
   указателя на ячейки, и если во время выполнения текущая ситуация уже есть в нашей
   хеш-таблице, то любезно говорим, что мы зациклились, начиная с такого-то места, ну
   или просто при проверке на корректность (то есть в isCorrect()) проверять циклы
   вида "[]", "[+-]", "[>++<]" и т. д.). Также мне показалось очень странным вводить
   2 функции readFile в классе FileL, если публичная её копия вызывает свою приватную
   с параметром, который приватной функции и так доступен. И в классе Operations зачем
   тоже мне непонятно, какой смысл делать type и amt приватными, если в коде всё равно
   присутствуют такие функции, как getType, getAmt и addAmt. В остальном всё хорошо
3) Лично я не нашёл частей кода, которые можно было бы улучшить с помощью новых
   возможностей новой версии Kotlin
