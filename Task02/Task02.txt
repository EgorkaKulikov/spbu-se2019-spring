Task02: CodeReview for pull request

    Задача: проанализировать пулреквест и написать по нему отчёт, ответив на следующие вопросы:
        1) Какую смысловую нагрузку несёт та или иная функция программы? Как программа работает в целом?
        2) Каково ваше отношение к замечаниям ревьюера и какие недочёты в коде видите вы?
        3) Можно ли как-то улучшить код с помощью тех возможностей Котлина, которые появились в нём уже после того, как этот код разрабатывался?
    
    Адрес: https://github.com/practice271/assignments/pull/213

Пункт первый: структура проекта и смысловая нагрузка функций.

        Проект состоит из 6 файлов с кодом, написанным на языке Kotlin:

                [CodeRunner.kt]:

                    interface CodeRunner :     
    
                        Определяет интерфейс интерпретатора некоторой программы.

                        Методы:

                            {runCode(source: String, input: String): String} :

                                Реализует исполнение программы (source: String) с входными данными (input: String) и возвращает результат String.

                [BrainInterpreter.kt]:

                    class BrainInterpreter:

                        Является реализацией интерпретатора языка Brainfuck.

                        Имеет 4 поля (source: String), (input: String), (jumpTable: IntArray), (memSize: Int) :
        
                            source - программа, написанная на Brainfuck,
                            input - входные данные программы,
                            jumpTable - таблица соответствий индексов  для '[' и ']',
                            memSize - количество байтов, выделенных под ячейки для Brainfuck (*).

                            Примечание:

                                (*): "В «классическом» Brainfuck, описанном Мюллером, размер ячейки — один байт, количество ячеек 30 000." (https://ru.wikipedia.org/wiki/Brainfuck).

                        Методы:

                            {runCode(s: String, i: String): String} :

                                Сохраняеет переданный текст программы (s) в (source),
                                переводит входные данные программы (i) в C-строку(*) и сохраняет в (input),
                                создает таблицу соответствий, путем вызова функции {setupJumps()}
                                и запускает процедуру {runCode()} по имплементации программы (source) с входными данными (input).
                            
                            {setupJumps()} :
                            
                                Заполняет таблицу (jumpTable), где для каждой скобки из {'[', ']'} определяет индекс ячейки парной скобки в программе (source).

                            {runCode()} :
                        
                                Исполняет программу (source) с входными данными (input) на Brainfuck и возвращает результат работы (output).

                [PetoohRunner.kt]:

                    class PetoohRunner:
                    
                        Является реализацией интерпретатора языка Petooh.

                        Имеет 1 поле (dictionary: Map<String, String>) :

                            dictionary - словарь перевода команд из Petooh в Brainfuck.

                        Методы:

                            {toBrainfuck(s: String): String} :

                                Переводит программу (s) c Petooh на Brainfuck и возвращает программу (res) на Brainfuck.

                            {runCode(source: String, input: String): String} :         
                            
                                Переводит программу (source) с Petooh на Brainfuck и запускает исполнение программы интерпретатором Brainfuck.

                [BrainGenerator.kt]:
                    
                    class BrainGenerator:
                        
                        Реализует компиляцию кода, написанного на языке Brainfuck, в байткод с помощью ObjectWeb ASM (*).

                        Примечание: 

                            (*) : https://en.wikipedia.org/wiki/ObjectWeb_ASM, https://asm.ow2.io/

                        Принимает имя генерируемого класса (className: String) и программу на Brainfuck (program: String).

                        Имеет 3 поля (labelOpenStack: Stack<Label>), (labelCloseStack: Stack<Label>), (b: ByteArray) :

                            labelOpenStack - стек для работы с отрывающимися скобками '[',
                            labelCloseStack - стек для работы с закрывающимися скобками ']',
                            b - массив байтов - байткод, в котором хранится структура генерируемого класса.

                        Методы:
    
                            {generate()} :

                                Создает объект (cv: ClassWriter = ClassWriter(1) (*)), с помощью которого осуществляется генерирование основной структуры класса,
                                создает объект (cw: CheckClassAdapter), который осуществляет проверку корректности вызова методов объекта (cv).
                                Далее все вызовы методов объекта (cv) осуществляются через соответствующие вызовы методов объекта (cw), 
                                что обеспечивает автоматическую проверку корректности вызова каждого метода.
                                Вызывается метод {cw.visit(V1_7, ACC_PUBLIC, className, null, "java/lang/Object", null)} (
                                    первый аргумент: version - версия класса,
                                    второй аргумент: access - флаги доступа класса,
                                    третий аргумент: name - внутреннее имя класса,
                                    четвертый аргумент: signature - сигнатура класса,
                                    пятый аргумент: superName - внутреннее имя суперкласса,
                                    шестой аргумент: interfaces - внутренние имена интерфейсов класса
                                ), который задает заголовок генерируемого класса.
                                Вызывается метод {mv = cw.visitMethod(ACC_PUBLIC or ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null)} (
                                    первый аргумент: access - флаги доступа класса,
                                    второй аргумент: name - имя метода,
                                    третий аргумент: desc - дескриптор метода,
                                    четвертый аргумент: signature - сигнатура метода,
                                    пятый аргумент: exceptions - внутреннее имя классов исключений метода,
                                ), который задает основной метод генерируемого класса.
                                Вызывается функция {genWrapper(mv)}, которая задает инструкции, определяющие поведение чтения и записи, для генерируемого класса.
                                Вызывается метод {rv = cw.visitMethod(ACC_PUBLIC or ACC_STATIC, "run", "(Ljava/io/Reader;Ljava/io/Writer;)V", null, null)},
                                который задает интструкции по чтению и записи для генерируемого класса.
                                Вызывается функция {genInstructions(rv)}, 
                                которая последовательно разбирает программу (program) на Brainfuck и для каждой команды добавляет соответствующие инструкции в генерируемый класс.
                                Вызывается метод {cw.visitEnd()},
                                который знаменует окончание работы с классом и информирует о том, что все поля и методы были обработаны.
                                В поле (b) сохраняется байт-код класса, созданного с помощью объекта (cv: ClassWriter) путем вызова метода {cv.toByteArray()}.
                                
                            {genWrapper(mv: MethodVisitor)} :

                                Задает инструкции, определяющие поведение чтения и записи, для генерируемого класса.

                            {genInstructions(mv: MethodVisitor)} :

                                Переводит программу на Brainfuck в инструкции для генерируемого класса.

                            {save()}:
                
                                Сохраняет байт-код (b) программы (program) на Brainfuck, как файл (className).class в локальную папку.
                                
                        Примечание:

                            (*): 1 в аргументе конструктора ClassWriter означает, что для каждого метода класса максимальный размер стека
                                 и максимальное количество локальных переменных будут вычисляться автоматически из сигнатуры и байт-кода каждого метода, 
                                 игнорируя аргументы метода visitMaxs метода MethodVisitor объекта ClassWriter.
                            

                [BrainRunner.kt]:
                    
                    class BrainRunner:
                    
                        Реализует исполнение программы на Brainfuck, путем генерирования соответствующего ей байт-кода и последующего его исполнения.

                        Методы:

                            {runCode(source: String, input: String): String} :

                                Создает экземпляр класса BrainGenerator (g: BrainGenerator = BrainGenerator("TestClass", source)),
                                генерирует байт-код соответствующий программе (source),
                                сохраняет его в локальную папку под именем TestClass.class.
                                С помощью URLClassLoader запускает метод {run} класса [TestClass], которому передает на чтение входные данные (r) 
                                и записывает результат работы в (w), который представляет в виде строки и возвращает как результат работы метода {runCode}.

Пункт второй: замечания ревьюеров и мои замечания

    Первые замечания содержат дискуссию на тему, весьма косвенно относящуюся к задаче.

    Остальные более дельные замечания:

        (https://github.com/practice271/assignments/pull/213#discussion-diff-45652710),
        (https://github.com/practice271/assignments/pull/213#discussion-diff-46422039):

            Комментарии по поводу замечания: Очень важное замечание про модификаторы доступа.
            Код: Исправлен.
            Рекомендации: Отсутствуют. 

        (https://github.com/practice271/assignments/pull/213#discussion-diff-45652725),
        (https://github.com/practice271/assignments/pull/213#discussion-diff-45653063):
        
            Комментарии по поводу замечания: Скорее относится к кодстайлу в принципе, чем к конкретному участку кода.
            Код: Исправлен.
            Рекомендации: Отсутствуют.

        (https://github.com/practice271/assignments/pull/213#discussion-diff-45652767):

            Комментарии по поводу замечания: Комментарий сформулирован слишком аккуратно. Модификатор обязан быть сделан private!
            Код: Не исправлен.
            Рекомендации: Исправить модификатор доступа функции {runCode()} на private.

        (https://github.com/practice271/assignments/pull/213#discussion-diff-45653057):

            Комментарии по поводу замечания: Очень важное замечание про возможность выхода за границы массива.
            Код: Не исправлен.
            Рекомендации: Хотя бы сделать минимальную обработку для ArrayIndexOutOfBoundsException.

        (https://github.com/practice271/assignments/pull/213#discussion-diff-46422275):

            
            Комментарии по поводу замечания: Очень важное замечание про магические константы.
            Код: Исправлен.
            Рекомендации: Отсутствуют. 
        
    Мои личные замечания:
    
        В [BrainInterpreter.kt] стоит переписать код функции {fun runCode(s: String, i: String): String} на такой:

            override fun runCode(source: String, input: String): String {
                this.source = source
                this.input = input + '\u0000'
                setupJumps()
                return runCode()
            }
        
        Избыточные конструкции:

            Лишняя точка с запятой: [BrainGenerator.kt] - строка 22.

            Избыточный модификатор видимости: [BrainGenerator.kt] - строки 18 и 263, [BrainInterpreter.kt] - строки 13 и 35, [BrainRunner.kt] - строка 10.

            Избыточный импорт: [PetoohRunner.kt] - строка 3.

Пункт третий: улучшаем код

    Использование поименнованной передачи аргументов в функции сделало бы код в NaN раз читабельнее. В остальном мест для улучшения в коде не выявлено.
    

              
