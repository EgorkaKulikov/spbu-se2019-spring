CODE REVIEW
Pull request 215

1) Анализ структуры проекта и конкретных классов и функций:
	public class BrainfuckCompiler -
имеет публичный метод compile, который преобразует программу на языке Brainfuck, переданную в класс при его создании в формате строки, в ByteArray - байткод сгенерированного Java-класса, который возвращается как результат функции.
Для генерации байткода используется фреймворк ASM и в частности классы Classwriter, который создает сам класс, и класс MethodVisitor, который использует паттерн Visitor для добавления инструкций. 
По адресу 1(ARRAY_REF) инизиализируется переменная, указывающая на массив, по адресу 2(PTR_REF) - на ячейку этого массива.
Кроме того, используются объекты-метки для кода Label(хранятся как стек меток(удобно реализовывать вложенные циклы), с помощью которых реализованы джампы в циклах и точки входа/выхода в программу) и коды операций для MethodVisitor'a opcodes (используются для передачи параметров в методы MethodVisitor'а для определения им что собственно нужно сделать, например:
mv.visitIntInsn(ASTORE, ARRAY_REF)
ASTORE - берет reference на массив из стека и кладет его в локальную переменную, переданную как параметр, то есть ARRAY_REF). 
Код программы компилируется за 1 проход, последовательно, каждая операция (за исключением цикла) обрабатывается независимо. Для повышения читаемости и модульности кода используются расширения класса MethodVisitor, 
которые разбирают все операции языка Brainfuck, то есть 
цикл [], input/output ',''.' , inc/dec '+''-', inc/dec указатель на ячейку массива '>','<'.

	public class BrainfuckInterpreter -
имеет публичный метод run, который делает попытку интерпретировать код программы на языке Brainfuck, переданный в класс при его создании в формате строки(и ничего не возвращает). Корректность программы верифицируется проверкой корректности скобочной структуры(больше ничего заранее не проверяется). Во время интерпретирования проверяются помимо скобочной структуры еще и выход за границу массива.
Об ошибках в ходе работы интерпретатора сигнализируют  runtime Exception'ы(которые не перехватываются):
UnexpectedRightBracket
("Unexpected right bracket at $index")
CorrespondingRightBracketNotFound
("No corresponding right bracket for left bracket at $instructionPointer")
ArrayIndexOutOfBoundsException
("Data tape has been accessed with an negative index")
Интерпретатор получает входные данные из inputStream и выводит в outputStream, которые также задаются при создании класса.
Все посторонние знаки в коде игнорируются, массив реализованный на основе Array, расширяется в 2 раза private функцией dataReallocate. Сама интерпретация кода последовательная, итеративно происходит обработка текущего символа, циклы реализуются с помощью поиска соответствующей скобки и изменения InstructionPointer.

	public class brainfuckCompilerTest -
имеет публичный метод testCompiler, который принимает на вход программу, входные параметры для нее и ожидаемый вывод, затем после выполнения теста делается assertEquals( сравнение и выброс AssertionError если неравно) полученного и ожидаемого результата. Перед тестированием заменяются input и output поток. Если в ходе тестирования в классе не оказалось методов, то бросается AssertionError. Для замены io потоков используются internal class'ы EmptyStream, TestPrintStream и TestInputStream. Для загрузки полученного класса используется internal class ByteArrayClassLoader с методом loadClass, который просто возвращает результат метода предка defineClass.
Тесты покрывают основную функциональность компилятора(корректность работы отдельных методов описанных в названии теста) и один общий случай "Hello world".

 public class brainfuckInterpreterTest -
не содержит публичного метода, все тесты реализуют вышеописанные процедуры самостоятельно. Работает аналогично тестированию компилятора, также перегружаются ввод/вывод, запускается интерпретатор и затем делается AssertEquals результатов.
Тесты покрывают корректность exception'ов и корректную работу программ, также для отдельных методов и "Hello world".


2) Анализ комментариев других ревьюверов и недостатки в коде:

	SlesarevIlya оставил 3 комментария, которые поправляют минорные недостатки в коде, слегка улучшают его читаемость или попросту сокращают кол-во строчек, и в 1 комментарии в brainfuckInterpreter хвалит за вынесение операции поиска соответствующей правой скобки в отдельный метод, что на самом деле сильно улучшает читаемость.
	Тем не менее, я заметил еще несколько минорных недостатков. В компиляторе в методе brainfuckIncPtr() стоило использовать PTR_REF, раз уж он был заведен, вместо магической константы 2. Кроме того, в интерпретаторе в 88 строке идет вызов функции getCorrespondingRightBracketIndex(instructionPointer + 1), что по моему мнению не интуитивно, так как instructionPointer указывает на скобку, и логично что если мы ищем соответствующую, то нужно передать сам instructionPointer без +1. Это ничего не ломает, нужно лишь чуть-чуть переделать сам метод. Еще наверное стоит добавить в компилятор немного комментариев, чтобы пояснить не очень понятные с первого взгяда имена файлов и наборы символов, как на 46-47 или на 67 строке например.
	В целом, мне понравились "говорящие" наименования в коде, стремление к модульности и информативные exception'ы. Тесты, конечно, покрывают довольно мало случаев, но я думаю задача полного покрытия тестами не стояла.

(3) Улучшение кода при помощи новых возможностей Kotlin:

Мест для улучшения при помощи новых возможностей Kotlin в коде не выявлено.
