Pull Request #219
https://github.com/practice271/assignments/pull/219

1. Работа программы в целом.
	Pull request состоит из следующих файлов: asciiToBrainfuck.kt, bfToJvmCompiler.kt, brainfuckInterpeter.kt, а также тестов к ним. 

asciiToBrainfuck.kt:
	Представлен класс translate, конвертирующий  ASCII в код на Brainfuck. 
		Метод translate: получает на вход строку в ASCII и возвращает ее в виде программы на Brainfuck. 
		nums – массив кодов символов, len – длина входной строки, далее с помощью полученной информации представлен сам алгоритм конвертирования в код на Brainfuck.
bfToJvmCompiler.kt:
	Подключены фреймворки для работы с байт-кодом, для работы с файловой системой через интерфейсы или классы.
	Класс BFToJvm: 
		Класс Opcode: с помощью enam-класса инициализируются всевозможные коды операций. 
		Метод tokenize – разбиение на лексемы: принимает код на Brainfuck и возвращает массив лексем используемых операций.
		Метод toByteCode: основной метод, возвращает байт-код Java, внутри используются классы CodeNode и CodeWriter, с помощью которых класс представляется в виде массива байт.
		Класс ByteArrayClassLoader(): 
			Метод loadClass: байт-код загружается в память.
		Функция saveToDisk: принимается байт-код программы и имя и сохраняется на диск.
	Функция loadClassAndRun: байт-код становится Java-классом.
brainfucktointerpreter.kt:
	Подключен пакет java.util для стека, а также библиотека Kotlin, предназначенная для работы с делигированными свойствами(не используется).
	Класс brainfuckInterpreter:
		Интерпретатор Brainfuck. Класс содержит поля размера массива, сам массив, в с помощью которого будут вычисляться ASCII символы и текущий индекс(по умолчанию на середине массива).
		Метод enlargeArray: метод расширения массива  tape при его переполнении.
		Метод interpete: основной метод класса. Принимает строку кода на Brainfuck, далее каждой команде на Brainfuck сопоставляется ее эквивалент(в том числе осуществляется частичная проверка на некорректность кода, если циклы построены неправильно),  последовательно печатаются проинтерпретированные символы, если в коде на Brainfuck была соответствующая команда, в циклах запускается рекурсивно, пока значение текущего индекса не ноль.  

2. Анализ замечаний ревьюеров и мои замечания:
	Комментриев к коду не так много, но все по делу. Особенно замечание про отсутствие интерфейса для единообразной работы в классе 	brainfuckInterpretеr. Но замечания исправлены не были.
	Замечания от меня(в основном по кодстайлу):
		public class brainfuckInterpeter() → public class BrainfuckInterpeter() 
		Метод toByteCode: большое количество “неговорящих” названий переменных(cn, mn0, lbls и др.), из-за чего очень усложняется читаемость кода для стороннего ревьюрера.
		class ByteArrayClassLoader(): ClassLoader() → class ByteArrayClassLoader: ClassLoader() (на JVM компилятором генерируется пустой конструктор).
		return res?.toString() ?: null → return res?.toString(), по стандарту Kotlin если res == null, то ничего не произойдет.
		if (res != null) res.append(curRes) → res?.append(curRes) (то же, это safe-access выражение)

3.  Улучшения кода с помощью новых возможностей Kotlin.
	Возможных улучшений я не выявила. Единственное, аргументы у main можно не писать, но функция закомментирована.
