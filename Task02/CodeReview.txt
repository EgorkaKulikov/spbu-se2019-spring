Pull Request #219
https://github.com/practice271/assignments/pull/219

1. Работа программы в целом.
	Pull request состоит из следующих файлов: asciiToBrainfuck.kt, bfToJvmCompiler.kt, brainfuckInterpeter.kt, а также тестов к ним. 

asciiToBrainfuck.kt:
	Состоит из класса translate, конвертирующий строку ASCII в код, выводящий ее на языке Brainfuck. 
		Метод translate: получает на вход строку в ASCII и возвращает ее в виде программы на Brainfuck, которая выводит данную строку. 
		nums – массив кодов символов, len – длина входной строки, далее с помощью полученной информации представлен сам алгоритм конвертирования в код на Brainfuck:
		в первой ячейке сохраняется длина строки, далее вычисляется среднее арифметическое кодов символов(т.е. значение, расстояние от которого до всех кодов символов будет минимальным) для оптимизации кода и записывается во вторую ячейку, затем для символов оптимизированным с помощью среднего у способом вычисяются и записываются в ячейки коды символов.
		(Я считаю, в общем случае данная оптимизация наиоболее подходящая. Но, например, если разность между минимальным и максимальным кодом символа довольно большая, то можно было бы вычислить и сохранить в ячейках два средних значения отдельно для маленьких и больших кодов и ходить уже от них, что сократило бы в резутате длину кода на Brainfuck) 
bfToJvmCompiler.kt:
	Подключена библиотека фреймворка для работы с байт-кодом, коллекция интерфейсов Files и Paths для работы с файловой системой, а именно для создания файла.
	Класс BFToJvm: 
		Класс Opcode: с помощью enam-класса инициализируются всевозможные коды операций. 
		Метод tokenize – разбиение на лексемы: принимает код на Brainfuck и возвращает массив лексем используемых операций.
		Метод toByteCode: метод, берущий на себя основную функциональность, возвращает байт-код Java, внутри используются класс ClassNode с помощью экземпляра которого класс представляется в виде массива байт. С помощью экземпляра класса MethodNode создается метод main, инициализируется список его инструкций и далее пошагово генерируются необходимые операции для каждой команды.
		Также для создания класса используется экземпляр класса ClassWriter для добавления необходимых инструкций. 
		Класс ByteArrayClassLoader(): 
			Класс - расширение класса ClassLoader.
			Метод loadClass: принимает имя будущего класса и его байт-код, с помощью метода defineClass байт-код конвертируется в экземпляр класса и возвращается.
	Функция saveToDisk: принимает байт-код и имя класса, с помощью метода get создается путь к файлу класса, далее с помощью метода write данные, соответственно, записываются.
	Функция loadClassAndRun: байт-код  непосредственно загружается в память и становится Java-классом.
brainfucktointerpreter.kt:
	Подключен пакет java.util для стека, а также библиотека Kotlin, предназначенная для работы с делигированными свойствами(не используется).
	Класс brainfuckInterpreter:
		Интерпретатор Brainfuck. Класс содержит поля размера массива, сам массив, в с помощью которого будут вычисляться ASCII символы и текущий индекс.
		Метод enlargeArray: метод расширения массива  tape при его переполнении.
		Метод interpete: основной метод класса. Принимает строку кода на Brainfuck, далее каждой команде на Brainfuck сопоставляется ее эквивалент(в том числе осуществляется частичная проверка на некорректность кода, если циклы построены неправильно: при встрече открывающей скобки рекурсивно проверяется правильность скобочной последовательности внутри), 
		последовательно печатаются в стандартный поток вывода проинтерпретированные символы либо записываются в результирующую строку, если в коде на Brainfuck была соответствующая команда, для работы с циклами запускается рекурсивно, пока значение текущего индекса не ноль.  

2. Анализ замечаний ревьюеров и мои замечания:
	Комментриев к коду не так много, но все по делу. Особенно замечание про отсутствие интерфейса для единообразной работы в классе brainfuckInterpretеr, так как добавление аргумента resToStdout кажется не очень обоснованным и не относится по функциональности к интерпретатору. Но замечания исправлены не были.
	> Нельзя сказать что рекурсия в данной ситуации это плохо, но все же лучше использовать стек
	Все таки плохо: не обрабатывается случай, если открывающих скобок больше закрывающих. С помощью стека это легко исправляется. Тем более, рекурсия затрудняет читаемость кода.
	Замечания от меня(в основном по кодстайлу):
		public class brainfuckInterpeter() → public class BrainfuckInterpeter() 
		Класс brainfuckInterpeter: поля size, tape и tapeInd следовало бы сделать приватными.
		Метод toByteCode: большое количество “неговорящих” названий переменных(cn, mn0, lbls и др.), из-за чего очень усложняется читаемость кода для стороннего ревьюрера.
		class ByteArrayClassLoader(): ClassLoader() → class ByteArrayClassLoader: ClassLoader() (на JVM компилятором генерируется пустой конструктор).
		return res?.toString() ?: null → return res?.toString(), по стандарту Kotlin если res == null, то метод не будет вызван и вернется null.
		if (res != null) res.append(curRes) → res?.append(curRes) (то же, это safe-access выражение)

3.  Улучшения кода с помощью новых возможностей Kotlin.
	Возможных улучшений я не выявила. Единственное, аргументы у main можно не писать, но функция закомментирована.