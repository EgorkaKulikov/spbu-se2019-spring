Pull Request #219
https://github.com/practice271/assignments/pull/219

1. Работа программы в целом.
	Pull request состоит из следующих файлов: asciiToBrainfuck.kt, bfToJvmCompiler.kt, brainfuckInterpeter.kt, а также тестов к ним. 

asciiToBrainfuck.kt:
	Состоит из класса translate, конвертирующий  ASCII в код на Brainfuck. 
		Метод translate: получает на вход строку в ASCII и возвращает ее в виде программы на Brainfuck. 
		nums – массив кодов символов, len – длина входной строки, далее с помощью полученной информации представлен сам алгоритм конвертирования в код на Brainfuck.
bfToJvmCompiler.kt:
	Подключена  библиотека фреймворка для работы с байт-кодом, коллекция интерфейсов Files и Paths для работы с файловой, а именно для создания файла.
	Класс BFToJvm: 
		Класс Opcode: с помощью enum-класса инициализируются всевозможные коды операций. 
		Метод tokenize – разбиение на лексемы: принимает код на Brainfuck и возвращает массив лексем используемых операций.
		Метод toByteCode: метод берущий на себя основную функциональность, возвращает байт-код Java, внутри используются классы CodeNode и CodeWriter, с помощью которых класс представляется в виде массива байт.
	Класс ByteArrayClassLoader(): 
		Класс - расширение класса ClassLoader.
		Метод loadClass: принимает имя будущего класса и его байт-код, с помощью метода defineClass байт-код конвертируется в экземпляр класса и возвращается.
	Функция saveToDisk: принимает байт-код и имя класса, с помощью метода get создается путь к файлу класса, далее с помощью метода write данные, соответственно, записываются.
	Функция loadClassAndRun: байт-код  непосредственно загружается в память и становится Java-классом.
brainfucktointerpreter.kt:
	Подключен пакет java.util для использования стека, а также библиотека Kotlin, предназначенная для работы с делигированными свойствами(не используется).
	Класс brainfuckInterpreter:
		Интерпретатор Brainfuck. Класс содержит поля размера массива, сам массив, в с помощью которого будут вычисляться ASCII символы и текущий индекс(по умолчанию на середине массива).
		Метод enlargeArray: метод расширения массива tape при его переполнении.
		Метод interpete: основной метод класса. Принимает строку кода на Brainfuck, далее каждой команде на Brainfuck сопоставляется ее эквивалент(в том числе осуществляется частичная проверка на некорректность кода, если циклы построены неправильно),  последовательно печатаются проинтерпретированные символы, если в коде на Brainfuck была соответствующая команда, в циклах запускается рекурсивно, пока значение текущего индекса не ноль.  
		
2. Анализ замечаний ревьюеров и мои замечания:
	Комментриев к коду не так много, но все по делу. Особенно замечание про отсутствие интерфейса для единообразной работы в классе brainfuckInterpretеr. Но замечания исправлены не были.
	Замечания:
		public class brainfuckInterpeter() → public class BrainfuckInterpeter() 
		Класс brainfuckInterpeter: поля size, tape и tapeInd следовало бы сделать приватными.
		Метод toByteCode: большое количество “неговорящих” названий переменных(cn, mn0, lbls и др.), из-за чего очень усложняется читаемость кода для стороннего ревьюрера.
		class ByteArrayClassLoader(): ClassLoader() → class ByteArrayClassLoader: ClassLoader() (на JVM компилятором генерируется пустой конструктор).
		return res?.toString() ?: null → return res?.toString(), по стандарту Kotlin если res == null, то ничего не произойдет.
		if (res != null) res.append(curRes) → res?.append(curRes) (то же, это safe-access выражение)

3.  Улучшения кода с помощью новых возможностей Kotlin.
	Возможных улучшений я не выявила. Единственное, аргументы у main можно не писать, но функция закомментирована.
