	< Code review for PullRequest #219 >
	
1) Общий анализ кода 

asciiToBrainFuck.kt:

	class [AsciiToBrainFuck] - класс для генерации BrainFuck кода из ASCII текста.
Содержит единственную Public функцию [translate], принимающую в [input] нужный текст
и возвращающую строку со сгенерированым кодом.
	Для уменьшения длины возвращаемого кода автор сначала увеличивает ячейки до
среднего значения всех символов текста, а затем доводит каждую из них до необходимого.


bfToJvmCompiler.kt:
	
	class [BFToJvm] - класс для генерации байт-кода JVM из кода BrainFuck. Он принимает
строку с кодом как аргумент. Автор использовал фреймворк ASM для удобной работы с
байт-кодом.
	В первую очередь код делится на лексемы с помощью функции [tokenize] и созданного
enum-класса [Opcode]. Функция [toByteCode] делает всю основную работу - принимает имя
для нового класса и размер памяти (аргументы [className] и [memorySize]) и последовательно
разбирает код на BrainFuck, добавляя необходимые операции на каждую команду. Создавать 
класс помогает [ClassWriter] из фреймворка ASM, откуда также взяты функции для добавления 
необходимых инструкций. 

	class [ByteArrayClassLoader] содержит функцию [loadClass], которая создает и 
возвращает экземпляр класса, принимая его имя и байт-код ([name] и [buf]).

	fun [saveToDisk] создает новый файл для класса и записывает в него полученный код.
Принимает имя класса и сам байт-код ([className] и [classByteArray]).

	fun [loadClassAndRun] собственно загружает и запускает полученный байт-код класса.
	
	
brainfuckInterpreter.kt:

	class [brainfuckInterpreter] - класс интерпретатора кода Brainfuck.
Содержит public-функцию [interprete] для работы с полученным кодом, которая возвращает (или
печатает в стандартный поток вывода) результат работы программы. Код разбирается
посимвольно, при выходе за границы ленты ячеек памяти вызывается private-функция
[enlargeArray] для увеличения рабочей памяти. Работа с циклами в коде реализована с помощью 
рекурсии.
	
Также есть несколько дополнительных файлов с тестами.
	
	

2) Комментарии к коду

	Автор придерживался некоторого единого кодстайла во всех файлах, хотя были
замечены некоторые небольшие отступления. Как мне кажется, автору стоило больше уделить
внимания на наименование переменных и комментирование кода. Без точного задания было
сложно понять суть работы класса [AsciiToBrainfuck] в одноименном файле. В смятение еще
вводили и некоторые переменные (например, [m], [mean], [input]), в название которых можно
было бы внести больше смысла. Та же проблема всплывает и в некоторых остальных файлах. 
	Иногда встречалиись строчки с закомментированным кодом, чего, мне кажется, в 
финальном продукте быть не должно. 

	Как правильно отметила @anna-marina, стоило по-другому реализовать разбор случаев 
в функции [interprete] файла [brainfuckInterpeter.kt]. Данный код кажется довольно 
громоздким и трудноразбираемым. Ситуацию ухудшает отсутствие отступов между смысловыми
кусками кода и написание однострочных веток if в одной строке с условием.
	Примерно то же самое хочется сказать и про использование рекурсии в той же функции. 
Данное решение может являться простым и элегантным, однако в данном случае это ухудшает 
читаемость кода, добавляя при этом больше логики. Это тоже было отмечено пользователем
@anna-marina.
	К тому же интересен разбор некорректного кода. Случай с лишними ']' разобран явно, 
однако интересно поведение цикла while(true) , если ему подать строку '[['. 
			
	Не совсем понятным я считаю и решение добавить в функцию [interprete] аргумент 
[resToStdout]. Это добавляет больше условий и действий в данную функцию, причем 
тех, за которые она, технически, не должна отвечать. Стоило бы вынести за эту функцию 
выбор того, куда нужно выводить результат.

	@anlun оставил лишь один комментарий по поводу длинной строчки в файле 
[bfToJvmCompilerTest.kt]. Данный комментарий кажется спорным, так как эта строчка хранит 
чистый код на Brainfuck, однако соглашусь, что стоило бы разделить ее на две. 

	В тесте [incorrectCodeTest] файла [bfInterpeterTest.kt] используются блоки try/catch 
и Assert, что кажется немного лишним, так как должны быть способы проверки на то, что 
метод выкинет нужное исколючение. 
	Также в тестах есть некоторые спорные моменты вида:
		StringBuilder().append(ch).append(ch).append(ch).toString()
		(строка 42 файла [bfInterpeterTest.kt])
		
		override fun read() = if (ind < input.length) input[ind++].toInt() else -1
		(строка 75 файла [bfToJvmCompilerTest.kt])
которые в данном случае не критичны, однако в других местах могли бы привести к проблемам. 


	В целом, я бы сказал, что над этим кодом можно было бы поработать куда больше. Как 
минимум, я бы написал комментарии во всех спорных моментах и содержащие хотя бы краткую 
информацию о каждом классе.



3) Улучшение кода с помощью нововведений Kotlin

	Заметных способов улучшить код с помощью новых возможностей котлина замечено не было. 
