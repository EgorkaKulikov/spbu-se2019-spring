<--Code review for pull_request #212-->

(1) Общий анализ структуры проекта и конкретных классов/функций:
	
	[public class BrainfuckCompiler] - класс с public функцией [compile]: в аргументах она принимает
код программы на BrainFuck и входные данные, возвращает массив байт - байткод, в котором хранится структура 
сгенерированного класса Java. Здесь подробнее: используется фреймворк ASM (https://asm.ow2.io/), и конкретно
классы [ClassWriter](генерирует основной каркас класса) и [MethodVisitor](добавляет инструкции), также 
вспомогательные классы с кодами для искомых операций и меток. Код программы на BrainFuck разбирается 
последовательно, на каждую команду добавляется соответствующая операция. Также в классе есть private функции - 
extensions для класса [MethodVisitor], описывают более сложные операции (например, цикл); в разы увеличивают 
читаемость кода.

	[public class BrainfuckInterpreter] - класс с public функцией [interpret], принимает код программы на 
BrainFuck и input, пытается его интерпретировать и возвращает output. Интерпретация кода обычная, по итерациям
происходит разбор соответствующего символа операции из BrainFuck (вся суть в том, что мы можем перемещаться 
вправо-влево по "ленте" массива, инкрементировать/декрементировать значение ячейки, вводить/выводить её, а также 
класть в стек и вытаскивать из него). Автор отдельно обращает внимание, что все посторонние знаки игнорируются,
а массив динамический, увеличивается в два раза при выходе за правую границу с помощью private функции [newArray].

	[public class ClassRunner] - класс с public функцией [loadClassAndRun], принимающей в аргументах 
байткод класса и его название, и с помощью унаследованного от [ClassLoader] [private class ByteArrayClassLoader] 
последовательно запускает все его методы - в том числе обрабатывает исключительные случаи, когда класс пустой.

	[public class Converter] - класс для конвертации ASCII текста в код на BrainFuck, печатющий этот текст.
Задача была в том, чтобы сократить этот код. Для этого сделаны public [simpleMethod], который делает это "в лоб" - 
в каждую ячейку последовательно вводит код символа и печатает его; а также 3 алгоритма, суть которых схожа: 
сначала увеличивать ячейки до какого-то числа (например, медианы или среднего всех кодов ASCII), потом ходить по ним
и "добивать" до конца с помощью стека, затем печатать. Public метод [convert] возвращает результат работы 
лучшего из алгоритмов.

	[public class PetoohCompiler] - класс, почти аналогичный [BrainfuckCompiler], но для синтаксиса PETOOH.
Включает private функцию [parse], которая разбирает на токены исходный код программы. Public метод [compile] 
возвращает байткод сгенерированного java-класса. Есть внутренний класс с инструкциями языка и extensions для
[MethodVisitor]

	+ 3 отдельных файла с классами для unit-тестов компилятора/интерпретатора Brainfuck, класса Converter 
и компилятора PETOOH. Выносятся в отдельные функции общие части (например, запуск ClassRunner у компиляторов), 
что довольно удобно.



(2) Анализ комментариев других ревьюверов и недостатки в коде:

	@onewhl оставила 2 комментария, по сути просто оценив красоту кода, хотя замечание о том, чтобы вынести
resize в отдельную функцию, пожалуй, правильное.

	Как абсолютно верно заметил @anlun, очень многое в классах обоих компиляторов можно было бы вынести в 
отдельные функции, как минимум чтобы не дублировать один и тот же код. Например, создать класс ImprovedMethodVisitor, 
расширяющий функционал MethodVisitor, или же в целом обобщить компиляторы одним классом Compiler, передавая язык,
к примеру, через generics. 

	Касательно расширения массива в BrainfuckInterpreter - наверное, логично было добавить еще и увеличение в 
обратную сторону, иначе exception при index < 0 и продолжение работы при index >= size выглядит странно. Как вариант,
"закольцевать" массив, или просто увеличивать его размер, изменяя значение index в плюс.

	В целом, наименования и комментарии в коде очень хороши, для прочтения и понимания усилий не требуется. 
Пожалуй, единственные замечания к алгоритмам в классе Converter - хотелось бы видеть более понятные стороннему 
ревьюверу названия, чем algo1, algo2 и algo3(внутри которого тоже происходит нечто странное). 

	Непонятна организация теста для Converter - algo3 вызывается для магической константы 16, при чем 
утверждается, что этот выбор оптимален - наверное, так делать не стоит. Еще, тогда остаются непокрытыми тестами 
другие случаи algo3 для иной константы.



(3) Улучшение кода при помощи новых возможностей Kotlin:

	[public class Instructions] можно было бы заменить на [enum class Instructions]. Сути это не меняет, но код,
возможно, станет приятнее. В целом, искомых мест для улучшения в коде не выявлено.
