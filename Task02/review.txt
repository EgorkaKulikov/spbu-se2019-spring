Pull Request #222

1. Работа программы
В пулреквесте указано три файла: BrainfuckCompiler, BrainfuckInterpreter, PetoohCompiler и unit-тесты к каждому из них. 
Каждый из этих трех файлов содержит одноименные классы.

BrainfuckCompiler:
Подключены пакеты фреймворка (в некоторых ресурсах написано, что библиотека, но на сайте asm иначе) ASM: 
ClassWriter – одноименный класс из этого пакета нужен для получения байт-кода, 
Label – метки, Opcodes.* - содержит названия инструкций байт-кода , MethodVisitor – используются методы для записывания  инструкций байт кода, 
java.util.* - используется Stack<T>. 
(Выше описано конкретное использование того или иного пакета в данном классе)

public class  BrainfuckCompiler принимает на вход строку программы (переменная program) и название файла с байт-кодом (переменная name).
Функция generateByteArray() является “основой” класса, которая возвращает байт-код программы. 
Для всех 8 команд Brainfuck’а написаны расширения класса MethodVisitor, где в каждом указаны соответствующие методы самого MethodVisitor с определенными инструкциями байт-кода.

BrainfuckInterpretator:
Содержит единственный класс BrainfuckInterpreter, являющийся интерпретатором для Brainfuck’a. 
Содержит поля (свойства) указателя на данные, массива, хранящего числа – коды символов, word – которая хранит строку, в которой по мере исполнения команд добавляются соответствующие кодировке ASCII символы. 
Метод interpret принимает код программы, сопоставляет каждому символу код на Kotlin (например, для “+” увеличиваем значение текущей ячейки массива кодов символов на 1), возвращает word.
PetoohCompiler:
public class PetoohCompiler очень похож на public class  BrainfuckCompiler:
наличие метода генерации байт кода программы, отличающегося только в конвертации исходного кода
написаны точно такие же расширения для MethodVisitor, за исключением функции конвертации команды ввод символа (MethodVisitor.brainfuckRead() в BrainfuckCompiler), т.к. команды ввода нет в языке Petooh. 
Код программы сначала “фильтруется” – в нем остаются только нужные символы из команд Petooh’a (adehkKoOru), далее – посимвольно записываем в буфер то или иное название команды, после конвертация этой команды в байт-код. 
Метод generateByteArray() возвращает байт-код программы.

2. Отношение к замечаниям ревьюверов и какие недочеты в коде вижу я
Замечания, оставленные ревьювером до изменений были достаточно точными. Например, что методы и поля в классе стоит располагать отдельно друг от друга.

Комментарий:
“Понравилась организация кода через расширение MethodVisitor. Элегантно.”
Не знаю, насколько полезны такого рода замечания, с одной стороны, не дают программисту, написавшему код, его улучшить, 
с другой, просто оценка кода с точки зрения красоты написания, что позволяет программисту осознавать, что он движется в правильном направлении в написании «хорошего» кода.
С комментарием по поводу длинной строки набора команд в тесте на “Hello World!\n” согласен. 
Следовало бы логически разбить одну строчку из команд Brainfuck’а на несколько, используя переход на новую строку и табуляцию (для циклов). Данное замечание осталось неисправленным.

Собственные наблюдения:
- Последние строчки в PetoohCompiler.kt: 
private fun prepare(program: String): String {
        return program.replace("[^adehkKoOru]".toRegex(), "");
    }
Стоило бы заменить на одну:
private fun prepare(program: String): String = program.replace("[^adehkKoOru]".toRegex(), "")
- Читая код, я не сразу понял назначение параметра класса BrainfuckCompiler name типа String (название файла, в который записывается байт-код исходной программы). 
Следовало дать название свойству более подробное, тем более, что эта переменная используется в классе редко. Например, fileNameOfByteCode.
- Наличие точки с запятой после перечисления импортов пакетов одной библиотеки (строка 6 BrainfuckCompiler.kt) и в функции prepare (строка 144 PetoohCompiler.kt) у оператора return.

3. Улучшение кода, с помощью новых возможностей Kotlin’а
Я не заметил возможности, которые могли бы улучшить код и при этом были добавлены в Kotlin после написания данного кода.
